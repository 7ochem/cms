{"version":3,"sources":["assetindexes/src/AssetIndexer.js"],"names":["SessionStatus","IndexingActions","AssetIndexer","constructor","$indexingSessionTable","sessions","maxConcurrentConnections","this","_currentConnectionCount","_tasksWaiting","_priorityTasks","_prunedSessionIds","indexingSessions","_currentIndexingSession","createSessionFromModel","sessionModel","_maxConcurrentConnections","ACTIONREQUIRED","reviewSessionId","getSessionStatus","session","updateIndexingSessionData","performIndexingStep","currentIndexingSession","indexingSession","getSessionId","renderIndexingSessionRow","$row","undefined","includes","remove","find","length","addClass","getIndexingSessionRowHtml","$existing","replaceWith","append","removeClass","discardIndexingSession","sessionId","processResponse","response","textStatus","error","alert","runTasks","skipDialog","_updateCurrentIndexingSession","stop","getReviewData","task","reviewSession","pruneWaitingTasks","missingEntries","missingFiles","files","Object","entries","missingFolders","folders","skippedFiles","getSkippedEntries","skippedFilesList","skippedFile","$confirmBody","Craft","t","haveMissingItems","itemText","enqueueTask","translationParams","items","id","uri","$","appendTo","Garnish","$bod","$body","$modal","html","$footer","$buttons","modal","hideOnEsc","hideOnShadeClick","type","class","text","initUiElements","on","ev","preventDefault","onHide","noop","hide","postData","getPostData","action","FINISH","params","startIndexing","cb","postActionRequest","START","concurrentSlots","i","Math","min","getEntriesRemaining","PROCESS","updateSizeAndPosition","settings","STOP","postParams","expandPostArray","modified","push","prioritize","shift","bind","values","sessionData","AssetIndexingSession","model","indexer","indexingSessionData","newTaskList","totalEntries","processedEntries","actionRequired","ACTIVE","WAITING","$tr","indexedVolumes","join","dateUpdated","$progressCell","css","progressBar","ProgressBar","updateProgressBar","data","getSessionStatusMessage","$actions","getActionButtons","reviewMessage","title","$container","target","parent","hasClass","discardMessage","aria-label","stopIndexingSession","getMissingEntries"],"mappings":"AAAA,aACA,IAAIA,cAIAA,iBAJJ,SAAIA,GAEAA,EAAcA,EAAa,eAAqB,GAAK,iBADxDA,EAAUA,EAAe,OAAA,GAAA,SACtBA,EAAcA,EAAc,QAAA,GAAoB,UAFpD,CAGIA,gBAAcA,cAAc,KAE/B,SAAEA,GAGCC,EAAe,MAAY,+BAF3BA,EAAJ,KAAA,sCAIIA,EAAe,QAAc,yCAHhCA,EAAUA,SAAiB,0CACxBA,EAAgB,OAAW,wCAH9B,CAIGA,kBAAgBA,gBAAU,KAM9B,MAAAC,aAUIC,YAAYC,EAAuBC,EAAUC,EAA2B,GALtEJ,KAAAA,wBAAa,KACfK,KAAAC,wBAAA,EACJD,KAAAE,cAAA,GACAF,KAAAG,eAAA,GACAH,KAAAI,kBAAA,GACIR,KAAWS,iBAACR,GACRG,KAAKM,0BAALP,EACAC,KAAKC,sBAALJ,EACAG,KAAKE,iBAAL,GACA,IAAKC,EAAL,EACA,IAAKC,MAAAA,KAALN,EAAA,CACKO,IAAAA,EAALL,KAAAO,uBAAAC,GACKC,EAAAA,qBAA4BV,cAAjCW,gBAAAC,IACKd,EAAwBA,EAAAA,gBAEzBc,GAOuC,MAAhCX,KAAKM,yBANLE,EAAXI,qBAAqCnB,cAAAiB,iBAC7BG,KAAUP,wBAAAO,EAA4BL,gBACtCK,KAAOC,0BAAwBrB,GAElCO,KAAAM,yBASDN,KAAKe,sBAJJC,6BAQL,OAAOhB,KAAKM,wBAHXQ,0BAAAG,GACJjB,KAAAK,iBAAAY,EAAAC,gBAAAD,EAUGjB,KAAKmB,yBAAyBF,GAJtCE,yBAAAN,GACA,IAAAO,EAWQ,QAAgBC,IAAZR,EACA,OAVJ,IAAKR,KAAAA,iBAAiBY,EAAgBC,iBAAkBD,KAAAA,kBAAxDK,SAAAT,EAAAK,gBAKR,OAJaC,KAAAA,sBAAyBF,KAAAA,uBAA9BJ,EAAAK,eAAA,MAAAK,cACH,GAAAvB,KAAAH,sBAAA2B,KAAA,YAAAC,QACDzB,KAAAH,sBAAA6B,SAAA,WAgBIN,EAAOP,EAAQc,4BACf,MAAMC,EAAY5B,KAAKH,sBAAsB2B,KAAK,uBAAyBX,EAAQK,eAAiB,MAbxGC,EAAAA,OAAyBN,EACrBe,EAAAC,YAAAT,GAEIpB,KAAAH,sBAAA2B,KAAA,SAAAM,OAAAV,GAiBJpB,KAAKH,sBAAsBkC,YAAY,UAO3CC,uBAAuBC,GAjBf,MAAApB,EAAAb,KAAAK,iBAAA4B,UACHjC,KAAAK,iBAAA4B,GAmBGjC,KAAKM,0BAA4B2B,IAlB9BpB,KAAAA,wBAAQc,MAqBf3B,KAAKmB,yBAAyBN,GAnB1Be,KAAAA,WAQRM,gBAAAC,EAAAC,GAEJ,GADApC,KAAAC,0BACA,YAAAmC,GAAAD,EAAAE,MAwBY,OAvBZC,MAAAH,EAAAE,YAsBYrC,KAAKuC,WAnBT,GAAqBlC,YAAfQ,GAAeR,EAAiB4B,QAAtC,CACO,MAAK5B,EAAAA,KAAiB4B,uBAA7BE,EAAAtB,SAuBIb,KAAKK,iBAAiBQ,EAAQK,gBAAkBL,EAtBhDb,KAAKM,yBAA4B2B,GAC5B3B,KAAAA,gCACRO,EAAAD,qBAAAnB,cAAAiB,gBAAAyB,EAAAK,WAOTxC,KAAAI,kBAAAkB,SAAAtB,KAAAM,yBA4BgBN,KAAKuC,WA3BrBvC,KAAAe,sBAgBqBf,KAAKI,kBAAkBkB,SAAStB,KAAKM,yBApBtDN,KAAAuC,WAHSpB,KAAAA,cAAyBN,GAqC9Bb,KAAKyC,gCA1Bc,YAAfL,GAA4BD,EAASE,MAC/BF,KAAAA,uBACNA,EAAAO,MAEAC,cAAA9B,GACH,MAAA+B,EAAA,CA4BGX,UAAWpB,EAAQK,eA3BnBkB,OAAU1C,gBAAkByC,SACtBtB,OAAO,CAAGoB,UAAK1B,EAAAA,iBAErBP,KAAKmB,YAAAA,GACL0B,cAAKJ,GA8BTzC,KAAK8C,kBAAkBjC,EAAQK,gBA7B3B,IAAIL,EAAQD,EAAAA,eACR,MAAKmC,EAAK3C,EAAkBkB,oBACxB0B,EAAmBnC,EAAnBoC,MAAAC,OAAAC,QAAAJ,EAAAE,OAAA,GADJG,EAGKL,EAAAM,QAAAH,OAAAC,QAAAJ,EAAAM,SAAA,GACDC,EAAAzC,EAAA0C,oBACH,GAAAD,EAAA7B,OAAA,CANL,IAQK+B,EAAUpD,GACX,IAAKW,MAAAA,KAALuC,EAECE,GAAA,OAAAC,SAEJC,EAAA5B,OAAA,yBACJ6B,MAAAC,EAAA,MAAA,6CA4BYD,MAAMC,EAAE,MAAO,2FAEdJ,0CAzBjB,MAAAK,EAAAb,EAAAvB,QAAA2B,EAAA3B,OA8BG,GAAIoC,EAAkB,CA7B1BlB,IAAc9B,EAAS,GACTmC,EAAGvB,SACAqC,GAAU5C,SAEX8B,EAAAvB,QAAA2B,EAAA3B,SAAEQ,GAAmBf,SAHjCkC,EAAA3B,SAKKsC,GAAL,WAkCI,MAAMC,EAAoB,CAAEC,MAAOH,GAhC3CjB,IAAchC,EAAS,GACdiC,IAAAA,MAAAA,EAAkBjC,KAAQK,EAC3BwC,GAAiB,oFAArBQ,OAAAC,iBAEMnB,IAAAA,MAAYkB,EAAGnB,KAAAA,EACfK,GAAiBL,mFAAvBmB,OAAAC,iBAmCIT,EAAa5B,OAAOsC,EAAG,yBAjCV3C,MAAjBmC,EAAyB,MAAA,kBAAAI,+BACjBR,MAAgBI,EAAG,MAAvB,mFAAAI,qDACWP,2CAGXC,MAAAA,EAAa5B,EAAb,6CAAqBuC,SAAAC,QAAAC,MACjCC,EAAsBb,EAAAA,uBAAeU,SAAiBI,GAAAC,KAAAhB,EAAAgB,QACtDC,EAAqBhB,EAAK,4BAAUU,SAAAI,GACpCG,EAAAR,EAAA,gCAAAC,SAAAM,GACAE,EAAsBrB,IAAAA,QAAAA,MAAiBiB,EAAA,CACvCK,WAAA,EACAC,kBANY,IA4CJ,GAAIlB,EAAkB,CApCGb,EAAAA,YAAavB,CAsC9BuD,KAAM,SArCVnB,MAAAA,MACIC,KAAWH,MAAfC,EAAA,MAAA,eACIZ,SAAavB,GACbqC,EAAAA,YAAA,CACHkB,KAAA,SAwCGC,MAAO,aAvCPjC,KAAYW,MAAClC,EAAb,MAAuB2B,iBACvBU,SAAYc,QAEZxB,EAAAA,YAAe3B,CACPuD,KAAI,SACfC,MAAA,aA0CGC,KAAMvB,MAAMC,EAAE,MAAO,QAzCnBI,SAAAA,GAANL,MAAAwB,eAAAX,GACAK,EAAI9B,wBA6CR0B,EAAOW,GAAG,SAAWC,IA5CZA,EAAAC,iBACDvC,EAAAA,SAAmBwC,OAAAnB,EAAAoB,KACtBX,EAAAY,OA8CD,MAAMC,EAAWpB,QAAQqB,YAAYnB,GA7CzBN,EAAYlB,MAAAA,gBAAc0C,GAClC3C,EAAcd,UAAKpB,EAAAK,eAgDvB,MAAM0B,EAAO,CA9Cbc,UAAqB7C,EAAEK,eACnC0E,OAAsBjC,gBAAekC,OACrCC,OAAqBnC,GAErB3D,KAAA+D,YAAsBhB,GAAAA,KAGbgD,cAAAD,EAAAE,GAgDDrC,MAAMsC,kBAAkBvG,gBAAgBwG,MAAOJ,EAAQ,CAAC3D,EAAUC,KA/C5DqC,IACAD,KAAKtC,gBAAKC,EAAuBkC,KAGvCtD,sBAoDA,GAnDI+D,KAAWxE,yBACXyE,KAAAA,iCAkDC/E,KAAKM,wBAhDNuD,OAEImB,MAAMnE,EADsBb,KAAAK,iBAAAL,KAAAM,yBAEvB6F,EAFuBnG,KAAAS,0BAAAT,KAAAC,wBAAf,IAKZoE,IALY+B,EAKHxB,EAAAA,EALdyB,KAAAC,IAAAH,EAAAtF,EAAA0F,uBAAAH,IAAA,CAME,MAAAxD,EAAa,CACLX,UADKpB,EAAAK,eAEJ0E,OAAAlG,gBAFI8G,QAGL7C,OAAQ,CAAA1B,UAAOjC,KAAfM,0BAGTN,KAAA+D,YAAAnB,IAOLe,oBAAA9C,GACAgE,KAAM4B,kBAAN5F,EAAAK,gBACAuD,MAAU7B,EAAA,CACH0C,UAAHzE,EAAAK,eACMwF,OAANhH,gBAAAiH,KACMlB,OAAN,CAAAxD,UAAApB,EAAAK,iBAEAlB,KAAM4G,YAAajD,GAAMkD,GAGZ/D,kBAAbb,GAKA,MAAK8B,EAAL,GAbJ,IAAA+C,GAAA,EAeH9G,KAAAI,kBAAA2G,KAAA9E,GAiDG,IAAK,MAAMW,KAAQ5C,KAAKE,cAhDd4F,EAAAA,YAAY7D,EAChBgE,EAAkBvG,KAAAA,GAAxBoH,GAAA,EAKJ/F,IACSf,KAAKM,cAAAA,GAqDdyD,YAAYnB,EAAMoE,GAAa,GAlDtBA,EACDhH,KAAAG,eAAA4G,KAAAnE,GAEE/B,KAAOX,cAAQG,KAAAA,GAsDrBL,KAAKuC,WAlDDA,WACIN,KAAAA,KAAS/B,cAAUgB,OAARlB,KADFG,eAAAsB,SAAA,GAAAzB,KAAAC,yBAAAD,KAAAS,2BAGCwB,KAAAA,KAAS/B,cAAOI,OAAAA,KAAAA,eAAAA,SAAAA,GAAAA,KAAAA,wBAAAA,KAAAA,2BAAAA,CAAlBN,KAAAC,0BAHZ,MAAA2C,EAAA5C,KAAAG,eAAAsB,OAAA,EAAAzB,KAAAG,eAAA8G,QAAAjH,KAAAE,cAAA+G,QAKKlD,MAAAA,kBAALnB,EAAAgD,OAAAhD,EAAAkD,OAAA9F,KAAAkC,gBAAAgF,KAAAlH,QAGRyC,gCACJ,IAAA,MAAA5B,KAAAqC,OAAAiE,OAAAnH,KAAAK,kBACA,GAAAQ,EAAAD,qBAAAnB,cAAAiB,eAEA,YADAV,KAAAM,wBAAAO,EAAAK,gBAOoBX,uBAAA6G,GAHZ,OAAA,IAAAC,qBAAAD,EAAApH,OAOJ,MAAAqH,qBACJzH,YAAA0H,EAAAC,GACAvH,KAAAwH,oBAAAF,EACAtH,KAAAuH,QAAAA,EAGQrG,eACI4F,OAAAA,KAAWU,oBAAftD,GAGIqC,sBACIkB,OAAAA,KAAYV,oBAAZW,aAAA1H,KAAAwH,oBAAAG,iBAmEZ/G,mBA7DQkG,OAAAA,KAAJU,oBAAcI,eACL1H,cAAgBuH,eAE5BzH,KAAAuH,QAAAvG,yBAAAhB,KAAAwH,oBAAAtD,GA+DczE,cAAcoI,OA7DrBb,cAAYc,QAOnBnG,4BAgEG,MAAMoG,EAAM3D,EAAE,gDAAkDpE,KAAKkB,eAAiB,MA/D1FqB,EAAQT,OAAG,OAAAoB,OAAAiE,OAAAnH,KAAAwH,oBAAAQ,gBAAAC,KAAA,MAAA,SACHF,EAAAjG,OAAK5B,OAAcuB,KAAnB+F,oBAAiCrH,YAA0B,SAC3D4H,EAAAjG,OAAA,OAAA9B,KAAAwH,oBAAAU,YAAA,SACH,MAAAC,EAAA/D,EAAA,8BAAAgE,IAAA,WAAA,YAiEKC,EAAc,IAAI1E,MAAM2E,YAAYH,GAAe,GAhEzDE,EAAYnI,aAAcuB,KAAnB+F,oBAA4BE,cAC/BW,EAAKpI,sBAALD,KAAAwH,oBAAAG,kBACAU,EAAaE,oBACb5E,EAAMsC,kBACT8B,EAAAjG,OAAAqG,EAAAK,KAAA,cAAAH,IACJN,EAAAjG,OAAA,OAAA9B,KAAAyI,0BAAA,SAkEG,MAAMC,EAAW1I,KAAK2I,mBAhEtB,OADJlG,EAAAA,aAAAA,OAAAA,GAAgC4B,SAAA0D,GACjBlH,EAOf8H,mBACJ,MAAA/D,EAAAR,EAAA,+BACA,GAAApE,KAAAY,oBAAAnB,cAAAiB,eAAA,CACA,MAAAkI,EAAAjF,MAAAC,EAAA,MAAA,UACAgB,EAAA9C,OAAAsC,EAAA,aAAA,CACAY,KAAA,SAmEgBC,MAAS,aACT4D,MAAOD,EAnEnBrI,aAAuB6G,IACRC,KAAAA,GAAJjC,GAAyBgC,QAAzB/B,IACV,MAAAyD,EAAA1E,EAAAiB,EAAA0D,QAAAC,SAqEeF,EAAWG,SAAS,cAnElC5B,EAAqB3F,SAAA,YACX4F,KAAOC,QAAR5E,cAAiB3C,UAG3B,MAAAkJ,EAAAvF,MAAAC,EAAA,MAAA,WAmFG,OAlFJgB,EAAA9C,OAAAsC,EAAA,aAAA,CACJY,KAAA,SACAC,MAAA,aAuEY4D,MAAOK,EACPC,aAAcD,IAvEtBhI,KAAYgI,GAAG9D,GAAA,QAAAC,IACCmC,EAAAA,SAAAA,cAGpB5C,EAAAlD,SAAA,YACA1B,KAAAuH,QAAA6B,oBAAApJ,UA0Ee4E,EAOX6D,0BACI,OAAQzI,KAAKY,oBA3EjBA,KAAAA,cAAmBF,eACN8G,OAAAA,MAAAA,EAAAA,MAAoBI,sBAE5B,KAAAnI,cAAAoI,OA6EO,OAAOlE,MAAMC,EAAE,MAAO,UA3E1B,KAAOnE,cAAcoI,QACxB,OAAAlE,MAAAC,EAAA,MAAA,YAMTyF,oBACA,OAAArJ,KAAAwH,oBAAAzE,eAGQgF,oBACIjG,OAAO9B,KAAAwH,oBAAcA","file":"AssetIndexer.min.js","sourcesContent":["\"use strict\";\nvar SessionStatus;\n(function (SessionStatus) {\n    SessionStatus[SessionStatus[\"ACTIONREQUIRED\"] = 0] = \"ACTIONREQUIRED\";\n    SessionStatus[SessionStatus[\"ACTIVE\"] = 1] = \"ACTIVE\";\n    SessionStatus[SessionStatus[\"WAITING\"] = 2] = \"WAITING\";\n})(SessionStatus || (SessionStatus = {}));\nvar IndexingActions;\n(function (IndexingActions) {\n    IndexingActions[\"START\"] = \"asset-indexes/start-indexing\";\n    IndexingActions[\"STOP\"] = \"asset-indexes/stop-indexing-session\";\n    IndexingActions[\"PROCESS\"] = \"asset-indexes/process-indexing-session\";\n    IndexingActions[\"OVERVIEW\"] = \"asset-indexes/indexing-session-overview\";\n    IndexingActions[\"FINISH\"] = \"asset-indexes/finish-indexing-session\";\n})(IndexingActions || (IndexingActions = {}));\n;\n/**\n * Actual classes start here\n */\n// Asset Indexer\n// =====================================================================================\nclass AssetIndexer {\n    /**\n     * @param $element The indexing session table\n     * @param sessions Existing indexing sessions\n     */\n    constructor($indexingSessionTable, sessions, maxConcurrentConnections = 3) {\n        this._currentIndexingSession = null;\n        this._currentConnectionCount = 0;\n        this._tasksWaiting = [];\n        this._priorityTasks = [];\n        this._prunedSessionIds = [];\n        this.indexingSessions = {};\n        this._maxConcurrentConnections = maxConcurrentConnections;\n        this.$indexingSessionTable = $indexingSessionTable;\n        this.indexingSessions = {};\n        let reviewSessionId = 0;\n        for (const sessionModel of sessions) {\n            let session = this.createSessionFromModel(sessionModel);\n            if (session.getSessionStatus() === SessionStatus.ACTIONREQUIRED && !reviewSessionId) {\n                reviewSessionId = session.getSessionId();\n            }\n            if (!reviewSessionId\n                && this._currentIndexingSession == null\n                && session.getSessionStatus() !== SessionStatus.ACTIONREQUIRED) {\n                this._currentIndexingSession = session.getSessionId();\n            }\n            this.updateIndexingSessionData(session);\n        }\n        if (this._currentIndexingSession) {\n            this.performIndexingStep();\n        }\n    }\n    get currentIndexingSession() {\n        return this._currentIndexingSession;\n    }\n    /**\n     * Update indexing session store\n     * @param session\n     */\n    updateIndexingSessionData(indexingSession) {\n        this.indexingSessions[indexingSession.getSessionId()] = indexingSession;\n        this.renderIndexingSessionRow(indexingSession);\n    }\n    /**\n     * Return a rendered indexing session row based on its id\n     * @param sessionId\n     */\n    renderIndexingSessionRow(session) {\n        let $row;\n        if (session === undefined) {\n            return;\n        }\n        if (!this.indexingSessions[session.getSessionId()] || this._prunedSessionIds.includes(session.getSessionId())) {\n            this.$indexingSessionTable.find('tr[data-session-id=\"' + session.getSessionId() + '\"]').remove();\n            if (this.$indexingSessionTable.find('tbody tr').length == 0) {\n                this.$indexingSessionTable.addClass('hidden');\n            }\n            return;\n        }\n        $row = session.getIndexingSessionRowHtml();\n        const $existing = this.$indexingSessionTable.find('tr[data-session-id=\"' + session.getSessionId() + '\"]');\n        if ($existing.length > 0) {\n            $existing.replaceWith($row);\n        }\n        else {\n            this.$indexingSessionTable.find('tbody').append($row);\n        }\n        this.$indexingSessionTable.removeClass('hidden');\n    }\n    /**\n     * Remove an indexing session\n     * @param sessionId\n     * @protected\n     */\n    discardIndexingSession(sessionId) {\n        const session = this.indexingSessions[sessionId];\n        delete this.indexingSessions[sessionId];\n        if (this._currentIndexingSession === sessionId) {\n            this._currentIndexingSession = null;\n        }\n        this.renderIndexingSessionRow(session);\n        this.runTasks();\n    }\n    /**\n     * Process an indexing response.\n     *\n     * @param response\n     * @param textStatus\n     */\n    processResponse(response, textStatus) {\n        this._currentConnectionCount--;\n        if (textStatus === 'success' && response.error) {\n            alert(response.error);\n            // A mere error shall not stop the party.\n            this.runTasks();\n            return;\n        }\n        if (textStatus === 'success' && response.session) {\n            const session = this.createSessionFromModel(response.session);\n            this.indexingSessions[session.getSessionId()] = session;\n            this.renderIndexingSessionRow(session);\n            this._updateCurrentIndexingSession();\n            if (session.getSessionStatus() === SessionStatus.ACTIONREQUIRED && !response.skipDialog) {\n                if (!this._prunedSessionIds.includes(this._currentIndexingSession)) {\n                    this.reviewSession(session);\n                }\n                else {\n                    this.runTasks();\n                }\n            }\n            else if (!this._prunedSessionIds.includes(this._currentIndexingSession)) {\n                this.performIndexingStep();\n            }\n            else {\n                this.runTasks();\n            }\n        }\n        this._updateCurrentIndexingSession();\n        if (textStatus === 'success' && response.stop) {\n            this.discardIndexingSession(response.stop);\n        }\n    }\n    getReviewData(session) {\n        const task = {\n            sessionId: session.getSessionId(),\n            action: IndexingActions.OVERVIEW,\n            params: { sessionId: session.getSessionId() }\n        };\n        this.enqueueTask(task);\n    }\n    reviewSession(session) {\n        this.pruneWaitingTasks(session.getSessionId());\n        let $confirmBody = $('<div></div>');\n        const missingEntries = session.getMissingEntries();\n        const missingFiles = missingEntries.files ? Object.entries(missingEntries.files) : [];\n        const missingFolders = missingEntries.folders ? Object.entries(missingEntries.folders) : [];\n        const skippedFiles = session.getSkippedEntries();\n        if (skippedFiles.length) {\n            let skippedFilesList = '';\n            for (const skippedFile of skippedFiles) {\n                skippedFilesList += `<li>${skippedFile}</li>`;\n            }\n            $confirmBody.append(`\n                <h2>${Craft.t('app', 'Skipped files')}</h2>\n                <p>${Craft.t('app', 'The following items were not indexed.')}</p>\n                <ul>\n                    ${skippedFilesList}\n                </ul>\n            `);\n        }\n        const haveMissingItems = missingFiles.length || missingFolders.length;\n        if (haveMissingItems) {\n            let itemText = '';\n            if (missingFiles.length) {\n                itemText += 'files';\n            }\n            if (missingFiles.length && missingFolders.length) {\n                itemText += ' and ';\n            }\n            if (missingFolders.length) {\n                itemText += 'folders';\n            }\n            const translationParams = { items: itemText };\n            let missingEntries = '';\n            for (const [id, uri] of missingFolders) {\n                missingEntries += `<li><label><input type=\"checkbox\" checked=\"checked\" name=\"deleteFolder[]\" value=\"${id}\"> ${uri}</label></li>`;\n            }\n            for (const [id, uri] of missingFiles) {\n                missingEntries += `<li><label><input type=\"checkbox\" checked=\"checked\" name=\"deleteAsset[]\" value=\"${id}\"> ${uri}</label></li>`;\n            }\n            $confirmBody.append($(`\n                <h2>${Craft.t('app', 'Missing {items}', translationParams)}</h2>\n                <p>${Craft.t('app', 'The following {items} could not be found. Should they be deleted from the index?', translationParams)}</p>\n                <ul>\n                    ${missingEntries}\n                </ul>\n            `));\n        }\n        const $modal = $('<form class=\"modal fitted confirmmodal\"/>').appendTo(Garnish.$bod);\n        const $body = $('<div class=\"body\"/>').appendTo($modal).html($confirmBody.html());\n        const $footer = $('<footer class=\"footer\"/>').appendTo($modal);\n        const $buttons = $('<div class=\"buttons right\"/>').appendTo($footer);\n        const modal = new Garnish.Modal($modal, {\n            hideOnEsc: false,\n            hideOnShadeClick: false,\n        });\n        if (haveMissingItems) {\n            let $cancelBtn = $('<button/>', {\n                type: 'button',\n                class: 'btn',\n                text: Craft.t('app', 'Keep them'),\n            })\n                .appendTo($buttons);\n            $('<button/>', {\n                type: 'submit',\n                class: 'btn submit',\n                text: Craft.t('app', 'Delete them'),\n            }).appendTo($buttons);\n        }\n        else {\n            $('<button/>', {\n                type: 'submit',\n                class: 'btn submit',\n                text: Craft.t('app', 'OK'),\n            }).appendTo($buttons);\n        }\n        Craft.initUiElements($body);\n        modal.updateSizeAndPosition();\n        $modal.on('submit', (ev) => {\n            ev.preventDefault();\n            modal.settings.onHide = $.noop;\n            modal.hide();\n            const postData = Garnish.getPostData($body);\n            const postParams = Craft.expandPostArray(postData);\n            postParams.sessionId = session.getSessionId();\n            // Make this the next task for sure?\n            const task = {\n                sessionId: session.getSessionId(),\n                action: IndexingActions.FINISH,\n                params: postParams\n            };\n            this.enqueueTask(task, true);\n        });\n    }\n    startIndexing(params, cb) {\n        Craft.postActionRequest(IndexingActions.START, params, (response, textStatus) => {\n            cb();\n            this.processResponse(response, textStatus);\n        });\n    }\n    performIndexingStep() {\n        if (!this._currentIndexingSession) {\n            this._updateCurrentIndexingSession();\n        }\n        if (!this._currentIndexingSession) {\n            return;\n        }\n        const session = this.indexingSessions[this._currentIndexingSession];\n        const concurrentSlots = this._maxConcurrentConnections - this._currentConnectionCount;\n        // Queue up at least enough tasks to use up all the free connections of finish the session.\n        for (let i = 0; i < Math.min(concurrentSlots, session.getEntriesRemaining()); i++) {\n            const task = {\n                sessionId: session.getSessionId(),\n                action: IndexingActions.PROCESS,\n                params: { sessionId: this._currentIndexingSession }\n            };\n            this.enqueueTask(task);\n        }\n    }\n    /**\n     * Stop and discard an indexing session.\n     *\n     * @param session\n     */\n    stopIndexingSession(session) {\n        this.pruneWaitingTasks(session.getSessionId());\n        const task = {\n            sessionId: session.getSessionId(),\n            action: IndexingActions.STOP,\n            params: { sessionId: session.getSessionId() }\n        };\n        this.enqueueTask(task, true);\n    }\n    /**\n     * Pune the waiting task list by removing all tasks for a session id.\n     *\n     * @param sessionId\n     */\n    pruneWaitingTasks(sessionId) {\n        const newTaskList = [];\n        let modified = false;\n        this._prunedSessionIds.push(sessionId);\n        for (const task of this._tasksWaiting) {\n            if (task.sessionId !== sessionId) {\n                newTaskList.push(task);\n            }\n            else {\n                modified = true;\n            }\n        }\n        if (modified) {\n            this._tasksWaiting = newTaskList;\n        }\n    }\n    enqueueTask(task, prioritize = false) {\n        if (prioritize) {\n            this._priorityTasks.push(task);\n        }\n        else {\n            this._tasksWaiting.push(task);\n        }\n        this.runTasks();\n    }\n    runTasks() {\n        if (this._tasksWaiting.length + this._priorityTasks.length === 0 || this._currentConnectionCount >= this._maxConcurrentConnections) {\n            return;\n        }\n        while (this._tasksWaiting.length + this._priorityTasks.length !== 0 && this._currentConnectionCount < this._maxConcurrentConnections) {\n            this._currentConnectionCount++;\n            const task = this._priorityTasks.length > 0 ? this._priorityTasks.shift() : this._tasksWaiting.shift();\n            Craft.postActionRequest(task.action, task.params, this.processResponse.bind(this));\n        }\n    }\n    _updateCurrentIndexingSession() {\n        for (const session of Object.values(this.indexingSessions)) {\n            if (session.getSessionStatus() !== SessionStatus.ACTIONREQUIRED) {\n                this._currentIndexingSession = session.getSessionId();\n                return;\n            }\n        }\n    }\n    /**\n     * Create a session from the data model.\n     *\n     * @param sessionData\n     * @private\n     */\n    createSessionFromModel(sessionData) {\n        return new AssetIndexingSession(sessionData, this);\n    }\n}\nclass AssetIndexingSession {\n    constructor(model, indexer) {\n        this.indexingSessionData = model;\n        this.indexer = indexer;\n    }\n    /**\n     * Get the session id\n     */\n    getSessionId() {\n        return this.indexingSessionData.id;\n    }\n    /**\n     * Get the remaining entry count for this sessions.\n     */\n    getEntriesRemaining() {\n        return this.indexingSessionData.totalEntries - this.indexingSessionData.processedEntries;\n    }\n    /**\n     * Get the session status.\n     */\n    getSessionStatus() {\n        if (this.indexingSessionData.actionRequired) {\n            return SessionStatus.ACTIONREQUIRED;\n        }\n        if (this.indexer.currentIndexingSession === this.indexingSessionData.id) {\n            return SessionStatus.ACTIVE;\n        }\n        return SessionStatus.WAITING;\n    }\n    /**\n     * Create row html as a JQuery object based on an indexing sessions\n     * @param session\n     * @private\n     */\n    getIndexingSessionRowHtml() {\n        const $tr = $('<tr class=\"indexingSession\" data-session-id=\"' + this.getSessionId() + '\">');\n        $tr.append('<td>' + Object.values(this.indexingSessionData.indexedVolumes).join(', ') + '</td>');\n        $tr.append('<td>' + this.indexingSessionData.dateCreated + '</td>');\n        $tr.append('<td>' + this.indexingSessionData.dateUpdated + '</td>');\n        const $progressCell = $('<td class=\"progress\"></td>').css('position', 'relative');\n        const progressBar = new Craft.ProgressBar($progressCell, false);\n        progressBar.setItemCount(this.indexingSessionData.totalEntries);\n        progressBar.setProcessedItemCount(this.indexingSessionData.processedEntries);\n        progressBar.updateProgressBar();\n        progressBar.showProgressBar();\n        $tr.append($progressCell.data('progressBar', progressBar));\n        $tr.append('<td>' + this.getSessionStatusMessage() + '</td>');\n        const $actions = this.getActionButtons();\n        $('<td></td>').append($actions).appendTo($tr);\n        return $tr;\n    }\n    /**\n     * Get action buttons for an indexing session\n     * @param session\n     * @private\n     */\n    getActionButtons() {\n        const $buttons = $('<div class=\"buttons\"></div>');\n        if (this.getSessionStatus() == SessionStatus.ACTIONREQUIRED) {\n            const reviewMessage = Craft.t('app', 'Review');\n            $buttons.append($('<button />', {\n                type: 'button',\n                'class': 'btn submit',\n                title: reviewMessage,\n                \"aria-label\": reviewMessage,\n            }).text(reviewMessage).on('click', ev => {\n                const $container = $(ev.target).parent();\n                if ($container.hasClass('disabled')) {\n                    return;\n                }\n                $container.addClass('disabled');\n                this.indexer.getReviewData(this);\n            }));\n        }\n        const discardMessage = Craft.t('app', 'Discard');\n        $buttons.append($('<button />', {\n            type: 'button',\n            'class': 'btn submit',\n            title: discardMessage,\n            \"aria-label\": discardMessage,\n        }).text(discardMessage).on('click', ev => {\n            if ($buttons.hasClass('disabled')) {\n                return;\n            }\n            $buttons.addClass('disabled');\n            this.indexer.stopIndexingSession(this);\n        }));\n        return $buttons;\n    }\n    /**\n     * Get the session status verbose message\n     *\n     * @param status\n     */\n    getSessionStatusMessage() {\n        switch (this.getSessionStatus()) {\n            case SessionStatus.ACTIONREQUIRED:\n                return Craft.t('app', 'Waiting for review');\n                break;\n            case SessionStatus.ACTIVE:\n                return Craft.t('app', 'Active');\n                break;\n            case SessionStatus.WAITING:\n                return Craft.t('app', 'Waiting');\n                break;\n        }\n    }\n    /**\n     * Return a list of missing entries for this session\n     */\n    getMissingEntries() {\n        return this.indexingSessionData.missingEntries;\n    }\n    /**\n     * Return a list of skipped entries for this session\n     */\n    getSkippedEntries() {\n        return this.indexingSessionData.skippedEntries;\n    }\n}\n"]}
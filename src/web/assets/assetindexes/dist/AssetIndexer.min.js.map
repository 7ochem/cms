{"version":3,"sources":["assetindexes/src/AssetIndexer.js"],"names":["SessionStatus","IndexingActions","AssetIndexer","constructor","$indexingSessionTable","sessions","maxConcurrentConnections","this","_currentConnectionCount","_tasksWaiting","_priorityTasks","_prunedSessionIds","indexingSessions","_currentIndexingSession","createSessionFromModel","sessionModel","_maxConcurrentConnections","ACTIONREQUIRED","reviewSessionId","getSessionStatus","QUEUE","session","CLI","updateIndexingSessionData","currentIndexingSession","indexingSession","getSessionId","renderIndexingSessionRow","$row","includes","find","remove","length","addClass","$existing","undefined","append","discardIndexingSession","sessionId","getIndexingSessionRowHtml","runTasks","processResponse","response","textStatus","error","alert","_updateCurrentIndexingSession","skipDialog","performIndexingStep","reviewSession","stop","getReviewData","pruneWaitingTasks","$confirmBody","missingEntries","getMissingEntries","missingFiles","files","Object","entries","missingFolders","folders","skippedFiles","skippedFilesList","skippedFile","Craft","t","task","itemText","id","uri","getSkippedEntries","$","translationParams","$modal","appendTo","Garnish","$bod","$body","html","$footer","$buttons","modal","Modal","hideOnEsc","hideOnShadeClick","haveMissingItems","class","text","type","initUiElements","updateSizeAndPosition","ev","preventDefault","settings","onHide","noop","getPostData","postParams","expandPostArray","postData","action","FINISH","params","enqueueTask","startIndexing","cb","$cancelBtn","i","Math","min","concurrentSlots","getEntriesRemaining","PROCESS","hide","newTaskList","modified","push","postActionRequest","prioritize","shift","bind","values","stopIndexingSession","sessionData","AssetIndexingSession","model","indexer","indexingSessionData","totalEntries","processedEntries","isCli","queueId","actionRequired","ACTIVE","$tr","indexedVolumes","join","dateCreated","dateUpdated","$progressCell","css","ProgressBar","progressBar","setProcessedItemCount","updateProgressBar","showProgressBar","data","getSessionStatusMessage","$actions","getActionButtons","title","reviewMessage","aria-label","on","$container","target","parent","hasClass","discardMessage","WAITING"],"mappings":"AAAA,aACA,IAAIA,cAMAA,iBANJ,SAAIA,GAEAA,EAAcA,EAAa,eAAqB,GAAK,iBADxDA,EAAUA,EAAe,OAAA,GAAA,SACtBA,EAAcA,EAAc,MAAA,GAAd,QACdA,EAAcA,EAAc,QAA5B,GAA6C,UAC7CA,EAAcA,EAAc,IAAW,GAAK,MAJhD,CAKIA,gBAAcA,cAAc,KAE/B,SAAEA,GAGCC,EAAe,MAAY,+BAF3BA,EAAJ,KAAA,sCAIIA,EAAe,QAAc,yCAHhCA,EAAUA,SAAiB,0CACxBA,EAAgB,OAAW,wCAH9B,CAIGA,kBAAgBA,gBAAU,KAM9B,MAAAC,aAUIC,YAAYC,EAAuBC,EAAUC,EAA2B,GALtEJ,KAAAA,wBAAa,KACfK,KAAAC,wBAAA,EACJD,KAAAE,cAAA,GACAF,KAAAG,eAAA,GACAH,KAAAI,kBAAA,GACIR,KAAWS,iBAACR,GACRG,KAAKM,0BAALP,EACAC,KAAKC,sBAALJ,EACAG,KAAKE,iBAAL,GACA,IAAKC,EAAL,EACA,IAAKC,MAAAA,KAALN,EAAA,CACKO,IAAAA,EAALL,KAAAO,uBAAAC,GACKC,EAAAA,qBAA4BV,cAAjCW,gBAAAC,IACKd,EAAwBA,EAAAA,gBAEzBc,GAOuC,MAAhCX,KAAKM,yBANLE,EAAXI,qBAAqCnB,cAAAoB,OACtBC,EAAQP,qBAAuBC,cAA1CO,KAQOD,EAAQF,qBAAuBnB,cAAciB,iBAPhDI,KAAQF,wBAAuBnB,EAAciB,gBAEhDV,KAAAgB,0BAAAF,GACIH,KAAAA,yBAKDX,KAAKM,sBAETW,6BACH,OAAAjB,KAAAM,wBAYLU,0BAA0BE,GAPtBD,KAAAA,iBAAJC,EAA6BC,gBAAAD,EACzBlB,KAAOoB,yBAAKd,GAchBc,yBAAyBN,GACrB,IAAIO,EATRL,QAAAA,IAAAA,EACSX,OAER,IAAAL,KAAAK,iBAAAS,EAAAK,iBAAAnB,KAAAI,kBAAAkB,SAAAR,EAAAK,gBAeO,OAdRnB,KAAAH,sBAAA0B,KAAA,uBAAAT,EAAAK,eAAA,MAAAK,cACJ,GAAAxB,KAAAH,sBAAA0B,KAAA,YAAAE,QACAzB,KAAAH,sBAAA6B,SAAA,WAEIN,EAAAA,EAAAA,4BACQC,MAAJM,EAAA3B,KAAAH,sBAAA0B,KAAA,uBAAAT,EAAAK,eAAA,MAaIQ,EAAUF,OAAS,EAZnBX,EAAYc,YAAWP,GAgBvBrB,KAAKH,sBAAsB0B,KAAK,SAASM,OAAOR,GAZhDrB,KAAKH,sBAAsB0B,YAAK,UAKnCO,uBAAAC,GAiBD,MAAMjB,EAAUd,KAAKK,iBAAiB0B,UAhB/BjB,KAAQkB,iBAAAA,GACTL,KAAAA,0BAAiB9B,IAkBnBG,KAAKM,wBAA0B,MAhB/BqB,KAAAA,yBAAAb,GADJd,KAGKiC,WAObC,gBAAAC,EAAAC,GAEA,GADApC,KAAAC,0BACA,YAAAmC,GAAAD,EAAAE,MAEcvB,OAiBFwB,MAAMH,EAASE,YAlBvBP,KAAAA,WAuBI,GAAmB,YAAfM,GAA4BD,EAASrB,QAAS,CApB9C,MAAKR,EAAAA,KAAAA,uBAAuC6B,EAAArB,SACvCR,KAAAA,iBAALQ,EAAAK,gBAAAL,EACHd,KAAAoB,yBAAAN,GAsBGd,KAAKuC,gCArBJnB,EAAAA,qBAAL3B,cAAAiB,gBAAAyB,EAAAK,WAQRxC,KAAAI,kBAAAkB,SAAAtB,KAAAM,yBAEaL,KAAAA,WAqBGD,KAAKyC,sBA9BbzC,KAAAI,kBAAAkB,SAAAtB,KAAAM,yBAIRN,KAAAiC,WAHKjC,KAAA0C,cAAA5B,GAUOwB,KAAMH,gCA0BS,YAAfC,GAA4BD,EAASQ,MAxBhCV,KAAAA,uBAALE,EAAAQ,MA4BRC,cAAc9B,GAzBNsB,MAAAA,EAAU,CACJtB,UAAUA,EAAKP,eAChBF,OAAAA,gBAAyBc,SACzBC,OAAAA,CAAAA,UAAAA,EAAyBN,iBAC9Bd,KAAKuC,YAAAA,GACLG,cAAY9B,GACRZ,KAAK6C,kBAAKzC,EAAkBkB,gBACxB,IAAAwB,EAAKJ,EAAc5B,eACtB,MAFDiC,EAGKjC,EAAAkC,oBACDC,EAAAF,EAAAG,MAAAC,OAAAC,QAAAL,EAAAG,OAAA,GACHG,EAAAN,EAAAO,QAAAH,OAAAC,QAAAL,EAAAO,SAAA,GAEAC,EAAUnD,EAAAA,oBACX,GAAAmD,EAAKd,OAAL,CADC,IAGAe,EAAA,GACD,IAAKvB,MAALwB,KAAAF,EACHC,GAAA,OAAAC,SA2BDX,EAAajB,OAAQ,yBAzBpBU,MAAAA,EAAAA,MAAAA,6CA2BQmB,MAAMC,EAAE,MAAO,2FAzBnB7B,0CAGbc,MAAAA,EAAuBK,EAAAxB,QAAA4B,EAAA5B,OACnB,GAAMmC,EAAO,CACT7B,IAAS8B,EAAU1C,GACXzB,EAAe+B,SACfoC,GAAA,SAAAZ,EAAAxB,QAAA4B,EAAA5B,SAHZoC,GAAA,SAMHR,EAAA5B,SA+BWoC,GAAY,WA7BfhB,MAAAA,EAA0B1B,CAAAA,MAAR0C,GACnBf,IAAAA,EAAiB,GACfC,IAAAA,MAAce,EAAGhD,KAAQkC,EACzBC,GAAeF,oFAArBe,OAAAC,iBAEMR,IAAAA,MAAYO,EAAGhD,KAAQkD,EAgCrBjB,GAAmB,mFAAkFe,OAAQC,iBA9B7GP,EAAAA,OAAJS,EAAA,yBAiCUP,MAAMC,EAAE,MAAO,kBAAmBO,+BAhCjCT,MAAAA,EAAX,MAA0BF,mFAAcW,qDAEvCnB,2CAGb,MAAAoB,EAAqBT,EAAAA,6CAAeU,SAAyCC,QAAAC,MAC7EC,EAAAN,EAAA,uBAAAG,SAAAD,GAAAK,KAAA1B,EAAA0B,QACAC,EAAsBjB,EAAAA,4BAAiBY,SAAAD,GACvCO,EAAAT,EAAA,gCAAAG,SAAAK,GALYE,EAAA,IAAAN,QAAAO,MAAAT,EAAA,CAOHU,WAAA,EAmCGC,kBAAkB,IAEtB,GAAIC,EAAkB,CAnCAd,EAAA,YAAA,CACdJ,KAAW,SAqCXmB,MAAO,MApCP/B,KAAYS,MAACjC,EAAjB,MAAyB,eAExB2C,SAAAM,GAsCDT,EAAE,YAAa,CArCXhB,KAAY,SACJ+B,MAAI,aACfC,KAAAvB,MAAAC,EAAA,MAAA,iBAuCES,SAASM,QApCXT,EAAA,YAAA,CAwCGiB,KAAM,SAvCJhB,MAAAA,aAA6BL,KAAAA,MAAAA,EAAAA,MAAAA,QAAnCO,SAAAM,GA4CJhB,MAAMyB,eAAeZ,GA1CjBI,EAAKS,wBACDrC,EAAAA,GAAAA,SAAmBsC,IACtBA,EAAAC,iBA4CDX,EAAMY,SAASC,OAASvB,EAAEwB,KA3CrBd,EAAOb,OACRf,MAAAA,EAAmBsB,QAAAqB,YAAAnB,GACtBoB,EAAAjC,MAAAkC,gBAAAC,GA6CDF,EAAW5D,UAAYjB,EAAQK,eA3C3C,MAAAyC,EAAsBF,CACtB3B,UAA2B4B,EAANxC,eACrB2E,OAAApG,gBAAAqG,OACAC,OAAsBjD,GAEtB/C,KANYiG,YAAArC,GAAA,KAQJsC,cAAYF,EAAKG,GACjBzC,MAAMa,kBAAU7E,gBAAuB0E,MAASD,EAAQK,CAA1CrC,EAA+CW,KACvD2B,IACAC,KAAAA,gBAAavC,EAAAC,KAGf0C,sBAGA,GALJ9E,KAAAM,yBAkDIN,KAAKuC,iCA7CD6D,KAAAA,wBACI,OAEJnB,MAAMvB,EAAQ1D,KAAOK,iBAAfL,KAAAM,yBAEL8D,EALLpE,KAAAS,0BAAAT,KAAAC,wBAOIiF,IAAI,IAAEmB,EAAA,EADKA,EAAAC,KAAAC,IAAAC,EAAA1F,EAAA2F,uBAAAJ,IAAA,CAEXrB,MAAOpB,EAAA,CACDF,UAAA5C,EAAeK,eACtBiD,OAASM,gBAJZgC,QAMCV,OAAA,CAAAjE,UAAA/B,KAAAM,0BAEON,KAAEiG,YADKrC,IAQnBO,oBAAqBkB,GACfrF,KAACsF,kBAAHxE,EAAAK,gBACAwD,MAAMY,EAASC,CACTmB,UAAN7F,EAAAK,eACM0E,OAAQnG,gBAAWgG,KACnBC,OAAAA,CAAU5D,UAAS6D,EAAAA,iBAgD7B5F,KAAKiG,YAAYrC,GAAM,GAvCtBf,kBAdDd,GAeH,MAAA6E,EAAA,GA+CG,IAAIC,GAAW,EA9CnBX,KAAAA,kBAA0BY,KAAA/E,GACtB2B,IAAMqD,MAAAA,KAAN/G,KAAwBN,cAClBkE,EAAA7B,YAAAA,EACGG,EAAgBC,KAAAA,GAkDjB0E,GAAW,EA7CVtE,IACRvC,KAAAE,cAAA0G,GAEGX,YAAArC,EAAAoD,GAAA,GACHA,EAkDGhH,KAAKG,eAAe2G,KAAKlD,GAGzB5D,KAAKE,cAAc4G,KAAKlD,GAhDxB5D,KAAM4D,WAEFkC,WACAE,KAAAA,KAAQ9F,cAAAuB,OAAAzB,KAAAG,eAAAsB,SAAA,GAAAzB,KAAAC,yBAAAD,KAAAS,2BAHZ,KAAAT,KAAAE,cAAAuB,OAAAzB,KAAAG,eAAAsB,SAAA,GAAAzB,KAAAC,wBAAAD,KAAAS,2BAAA,CAKKwF,KAAAA,0BACR,MAAArC,EAAA5D,KAAAG,eAAAsB,OAAA,EAAAzB,KAAAG,eAAA8G,QAAAjH,KAAAE,cAAA+G,QACJvD,MAAAqD,kBAAAnD,EAAAkC,OAAAlC,EAAAoC,OAAAhG,KAAAkC,gBAAAgF,KAAAlH,QAGLuC,gCACA,IAAA,MAAAzB,KAAAqC,OAAAgE,OAAAnH,KAAAK,kBACA,GAAAS,EAAAF,qBAAAnB,cAAAoB,OAqDmBC,EAAQF,qBAAuBnB,cAAcsB,KAC7CD,EAAQF,qBAAuBnB,cAAciB,eApDnDmC,YADTuE,KAAmB9G,wBAAUQ,EAAAK,gBAS7BZ,uBAAA8G,GACJ,OAAA,IAAAC,qBAAAD,EAAArH,OAGA,MAAAsH,qBAyDI1H,YAAY2H,EAAOC,GACfxH,KAAKyH,oBAAsBF,EAzD/B1E,KAAAA,QAAkBd,EA+DlBZ,eA3DI,OAAWyC,KAAX6D,oBAAwBvH,GAMnBuG,sBACJ,OAAAzG,KAAAyH,oBAAAC,aAAA1H,KAAAyH,oBAAAE,iBAIJ/G,mBA6DG,OAAIZ,KAAKyH,oBAAoBG,MA5DtBnI,cAAoBsB,IAElBZ,KAAAA,oBAAL0H,QAECpI,cAAAoB,MAEJb,KAAAyH,oBAAAK,eA6DUrI,cAAciB,eA3D5BV,KAAAwH,QAAAvG,yBAAAjB,KAAAyH,oBAAA3D,GA8DcrE,cAAcsI,OA5DhB7H,cAAcuB,QAMnBiC,4BACH,MAAAsE,EAAA/D,EAAA,gDAAAjE,KAAAmB,eAAA,MACJ6G,EAAAnG,OAAA,OAAAsB,OAAAgE,OAAAnH,KAAAyH,oBAAAQ,gBAAAC,KAAA,MAAA,SAgEGF,EAAInG,OAAO,OAAS7B,KAAKyH,oBAAoBU,YAAc,SA/D/D5F,EAAAA,OAAAA,OAAAA,KAA6BkF,oBAAGW,YAAA,SAC5B,MAAKC,EAAiBlF,EAAM,8BAA5BmF,IAA4D,WAAA,YACpDxH,EAAQF,IAAAA,MAAR2H,YAA+B9I,GAC5BqB,GAEH0H,EAAKlI,aAAAA,KAALmH,oBAAuCtG,cACvCqH,EAAAC,sBAAAzI,KAAAyH,oBAAAE,kBACHa,EAAAE,oBACJF,EAAAG,kBACJX,EAAAnG,OAAAwG,EAAAO,KAAA,cAAAJ,IACDR,EAAAnG,OAAA,OAAA7B,KAAA6I,0BAAA,SACJ,MAAAC,EAAA9I,KAAA+I,mBAEA,OADA9E,EAAA,aAAApC,OAAAiH,GAAA1E,SAAA4D,GACAA,EAKKe,mBAiEG,GAAI/I,KAAKY,qBAAuBnB,cAAcoB,OAASb,KAAKY,qBAAuBnB,cAAcsB,IApYtF,OAAAkD,IAqUbqD,MAAAA,EAAAA,EAAqB,+BACvB1H,GAAAA,KAAY2H,oBAAgB9H,cAAAiB,eAAA,CACnB+G,MAAAA,EAAsBF,MAA3B5D,EAAA,MAAA,UACK6D,EAAUA,OAAfvD,EAAA,aAAA,CACHiB,KAAA,SACDF,MAAA,aACJgE,MAAAC,EACAC,aAAAD,IAmEehE,KAAKgE,GAAeE,GAAG,QAAS9D,IAC/B,MAAM+D,EAAanF,EAAEoB,EAAGgE,QAAQC,SAnE7BF,EAAAG,SAAA,cAGfH,EAAA1H,SAAA,YACJ1B,KAAAwH,QAAA5E,cAAA5C,UAuEQ,MAAMwJ,EAAiB9F,MAAMC,EAAE,MAAO,WAatC,OAlFJ8C,EAAAA,OAAsBxC,EAAA,aAAA,CACXiB,KAAKuC,SACfzC,MAAA,aACDgE,MAAAQ,EACJN,aAAAM,IACAvE,KAAAuE,GAAAL,GAAA,QAAA9D,IAuEgBX,EAAS6E,SAAS,cArEtB7E,EAAK+C,SAAAA,YACLzH,KAAOP,QAAAA,oBAAPO,UA0EG0E,EAnENmE,0BA2ED,OAAQ7I,KAAKY,oBA1ET,KAAK4G,cAAQvG,eACNxB,OAAAA,MAAcsI,EAAAA,MAArB,sBA6EA,KAAKtI,cAAcsI,OA3EhBtI,OAAAA,MAAcgK,EAAAA,MAArB,UAEJ,KAAAhK,cAAAgK,QACJ,OAAA/F,MAAAC,EAAA,MAAA,WAEA,KAAAlE,cAAAoB,MACA,OAAA6C,MAAAC,EAAA,MAAA,yBA8EY,KAAKlE,cAAcsB,IA7E3BiB,OAAAA,MAAyB2B,EAAG,MAAA,oBAOxB6E,oBACAA,OAAWxI,KAACyI,oBAAsB1F,eAKlCiB,oBACE,OAAAhE,KAAa6B,oBAAiBuC","file":"AssetIndexer.min.js","sourcesContent":["\"use strict\";\nvar SessionStatus;\n(function (SessionStatus) {\n    SessionStatus[SessionStatus[\"ACTIONREQUIRED\"] = 0] = \"ACTIONREQUIRED\";\n    SessionStatus[SessionStatus[\"ACTIVE\"] = 1] = \"ACTIVE\";\n    SessionStatus[SessionStatus[\"QUEUE\"] = 2] = \"QUEUE\";\n    SessionStatus[SessionStatus[\"WAITING\"] = 3] = \"WAITING\";\n    SessionStatus[SessionStatus[\"CLI\"] = 4] = \"CLI\";\n})(SessionStatus || (SessionStatus = {}));\nvar IndexingActions;\n(function (IndexingActions) {\n    IndexingActions[\"START\"] = \"asset-indexes/start-indexing\";\n    IndexingActions[\"STOP\"] = \"asset-indexes/stop-indexing-session\";\n    IndexingActions[\"PROCESS\"] = \"asset-indexes/process-indexing-session\";\n    IndexingActions[\"OVERVIEW\"] = \"asset-indexes/indexing-session-overview\";\n    IndexingActions[\"FINISH\"] = \"asset-indexes/finish-indexing-session\";\n})(IndexingActions || (IndexingActions = {}));\n;\n/**\n * Actual classes start here\n */\n// Asset Indexer\n// =====================================================================================\nclass AssetIndexer {\n    /**\n     * @param $element The indexing session table\n     * @param sessions Existing indexing sessions\n     */\n    constructor($indexingSessionTable, sessions, maxConcurrentConnections = 3) {\n        this._currentIndexingSession = null;\n        this._currentConnectionCount = 0;\n        this._tasksWaiting = [];\n        this._priorityTasks = [];\n        this._prunedSessionIds = [];\n        this.indexingSessions = {};\n        this._maxConcurrentConnections = maxConcurrentConnections;\n        this.$indexingSessionTable = $indexingSessionTable;\n        this.indexingSessions = {};\n        let reviewSessionId = 0;\n        for (const sessionModel of sessions) {\n            let session = this.createSessionFromModel(sessionModel);\n            if (session.getSessionStatus() === SessionStatus.ACTIONREQUIRED && !reviewSessionId) {\n                reviewSessionId = session.getSessionId();\n            }\n            if (!reviewSessionId\n                && this._currentIndexingSession == null\n                && session.getSessionStatus() !== SessionStatus.QUEUE\n                && session.getSessionStatus() !== SessionStatus.CLI\n                && session.getSessionStatus() !== SessionStatus.ACTIONREQUIRED) {\n                this._currentIndexingSession = session.getSessionId();\n            }\n            this.updateIndexingSessionData(session);\n        }\n        if (this._currentIndexingSession) {\n            this.performIndexingStep();\n        }\n    }\n    get currentIndexingSession() {\n        return this._currentIndexingSession;\n    }\n    /**\n     * Update indexing session store\n     * @param session\n     */\n    updateIndexingSessionData(indexingSession) {\n        this.indexingSessions[indexingSession.getSessionId()] = indexingSession;\n        this.renderIndexingSessionRow(indexingSession);\n    }\n    /**\n     * Return a rendered indexing session row based on its id\n     * @param sessionId\n     */\n    renderIndexingSessionRow(session) {\n        let $row;\n        if (session === undefined) {\n            return;\n        }\n        if (!this.indexingSessions[session.getSessionId()] || this._prunedSessionIds.includes(session.getSessionId())) {\n            this.$indexingSessionTable.find('tr[data-session-id=\"' + session.getSessionId() + '\"]').remove();\n            if (this.$indexingSessionTable.find('tbody tr').length == 0) {\n                this.$indexingSessionTable.addClass('hidden');\n            }\n            return;\n        }\n        $row = session.getIndexingSessionRowHtml();\n        const $existing = this.$indexingSessionTable.find('tr[data-session-id=\"' + session.getSessionId() + '\"]');\n        if ($existing.length > 0) {\n            $existing.replaceWith($row);\n        }\n        else {\n            this.$indexingSessionTable.find('tbody').append($row);\n        }\n        this.$indexingSessionTable.removeClass('hidden');\n    }\n    /**\n     * Remove an indexing session\n     * @param sessionId\n     * @protected\n     */\n    discardIndexingSession(sessionId) {\n        const session = this.indexingSessions[sessionId];\n        delete this.indexingSessions[sessionId];\n        if (this._currentIndexingSession === sessionId) {\n            this._currentIndexingSession = null;\n        }\n        this.renderIndexingSessionRow(session);\n        this.runTasks();\n    }\n    /**\n     * Process an indexing response.\n     *\n     * @param response\n     * @param textStatus\n     */\n    processResponse(response, textStatus) {\n        this._currentConnectionCount--;\n        if (textStatus === 'success' && response.error) {\n            alert(response.error);\n            // A mere error shall not stop the party.\n            this.runTasks();\n            return;\n        }\n        if (textStatus === 'success' && response.session) {\n            const session = this.createSessionFromModel(response.session);\n            this.indexingSessions[session.getSessionId()] = session;\n            this.renderIndexingSessionRow(session);\n            this._updateCurrentIndexingSession();\n            if (session.getSessionStatus() === SessionStatus.ACTIONREQUIRED && !response.skipDialog) {\n                if (!this._prunedSessionIds.includes(this._currentIndexingSession)) {\n                    this.reviewSession(session);\n                }\n                else {\n                    this.runTasks();\n                }\n            }\n            else if (!this._prunedSessionIds.includes(this._currentIndexingSession)) {\n                this.performIndexingStep();\n            }\n            else {\n                this.runTasks();\n            }\n        }\n        this._updateCurrentIndexingSession();\n        if (textStatus === 'success' && response.stop) {\n            this.discardIndexingSession(response.stop);\n        }\n    }\n    getReviewData(session) {\n        const task = {\n            sessionId: session.getSessionId(),\n            action: IndexingActions.OVERVIEW,\n            params: { sessionId: session.getSessionId() }\n        };\n        this.enqueueTask(task);\n    }\n    reviewSession(session) {\n        this.pruneWaitingTasks(session.getSessionId());\n        let $confirmBody = $('<div></div>');\n        const missingEntries = session.getMissingEntries();\n        const missingFiles = missingEntries.files ? Object.entries(missingEntries.files) : [];\n        const missingFolders = missingEntries.folders ? Object.entries(missingEntries.folders) : [];\n        const skippedFiles = session.getSkippedEntries();\n        if (skippedFiles.length) {\n            let skippedFilesList = '';\n            for (const skippedFile of skippedFiles) {\n                skippedFilesList += `<li>${skippedFile}</li>`;\n            }\n            $confirmBody.append(`\n                <h2>${Craft.t('app', 'Skipped files')}</h2>\n                <p>${Craft.t('app', 'The following items were not indexed.')}</p>\n                <ul>\n                    ${skippedFilesList}\n                </ul>\n            `);\n        }\n        const haveMissingItems = missingFiles.length || missingFolders.length;\n        if (haveMissingItems) {\n            let itemText = '';\n            if (missingFiles.length) {\n                itemText += 'files';\n            }\n            if (missingFiles.length && missingFolders.length) {\n                itemText += ' and ';\n            }\n            if (missingFolders.length) {\n                itemText += 'folders';\n            }\n            const translationParams = { items: itemText };\n            let missingEntries = '';\n            for (const [id, uri] of missingFolders) {\n                missingEntries += `<li><label><input type=\"checkbox\" checked=\"checked\" name=\"deleteFolder[]\" value=\"${id}\"> ${uri}</label></li>`;\n            }\n            for (const [id, uri] of missingFiles) {\n                missingEntries += `<li><label><input type=\"checkbox\" checked=\"checked\" name=\"deleteAsset[]\" value=\"${id}\"> ${uri}</label></li>`;\n            }\n            $confirmBody.append($(`\n                <h2>${Craft.t('app', 'Missing {items}', translationParams)}</h2>\n                <p>${Craft.t('app', 'The following {items} could not be found. Should they be deleted from the index?', translationParams)}</p>\n                <ul>\n                    ${missingEntries}\n                </ul>\n            `));\n        }\n        const $modal = $('<form class=\"modal fitted confirmmodal\"/>').appendTo(Garnish.$bod);\n        const $body = $('<div class=\"body\"/>').appendTo($modal).html($confirmBody.html());\n        const $footer = $('<footer class=\"footer\"/>').appendTo($modal);\n        const $buttons = $('<div class=\"buttons right\"/>').appendTo($footer);\n        const modal = new Garnish.Modal($modal, {\n            hideOnEsc: false,\n            hideOnShadeClick: false,\n        });\n        if (haveMissingItems) {\n            let $cancelBtn = $('<button/>', {\n                type: 'button',\n                class: 'btn',\n                text: Craft.t('app', 'Keep them'),\n            })\n                .appendTo($buttons);\n            $('<button/>', {\n                type: 'submit',\n                class: 'btn submit',\n                text: Craft.t('app', 'Delete them'),\n            }).appendTo($buttons);\n        }\n        else {\n            $('<button/>', {\n                type: 'submit',\n                class: 'btn submit',\n                text: Craft.t('app', 'OK'),\n            }).appendTo($buttons);\n        }\n        Craft.initUiElements($body);\n        modal.updateSizeAndPosition();\n        $modal.on('submit', (ev) => {\n            ev.preventDefault();\n            modal.settings.onHide = $.noop;\n            modal.hide();\n            const postData = Garnish.getPostData($body);\n            const postParams = Craft.expandPostArray(postData);\n            postParams.sessionId = session.getSessionId();\n            // Make this the next task for sure?\n            const task = {\n                sessionId: session.getSessionId(),\n                action: IndexingActions.FINISH,\n                params: postParams\n            };\n            this.enqueueTask(task, true);\n        });\n    }\n    startIndexing(params, cb) {\n        Craft.postActionRequest(IndexingActions.START, params, (response, textStatus) => {\n            cb();\n            this.processResponse(response, textStatus);\n        });\n    }\n    performIndexingStep() {\n        if (!this._currentIndexingSession) {\n            this._updateCurrentIndexingSession();\n        }\n        if (!this._currentIndexingSession) {\n            return;\n        }\n        const session = this.indexingSessions[this._currentIndexingSession];\n        const concurrentSlots = this._maxConcurrentConnections - this._currentConnectionCount;\n        // Queue up at least enough tasks to use up all the free connections of finish the session.\n        for (let i = 0; i < Math.min(concurrentSlots, session.getEntriesRemaining()); i++) {\n            const task = {\n                sessionId: session.getSessionId(),\n                action: IndexingActions.PROCESS,\n                params: { sessionId: this._currentIndexingSession }\n            };\n            this.enqueueTask(task);\n        }\n    }\n    /**\n     * Stop and discard an indexing session.\n     *\n     * @param session\n     */\n    stopIndexingSession(session) {\n        this.pruneWaitingTasks(session.getSessionId());\n        const task = {\n            sessionId: session.getSessionId(),\n            action: IndexingActions.STOP,\n            params: { sessionId: session.getSessionId() }\n        };\n        this.enqueueTask(task, true);\n    }\n    /**\n     * Pune the waiting task list by removing all tasks for a session id.\n     *\n     * @param sessionId\n     */\n    pruneWaitingTasks(sessionId) {\n        const newTaskList = [];\n        let modified = false;\n        this._prunedSessionIds.push(sessionId);\n        for (const task of this._tasksWaiting) {\n            if (task.sessionId !== sessionId) {\n                newTaskList.push(task);\n            }\n            else {\n                modified = true;\n            }\n        }\n        if (modified) {\n            this._tasksWaiting = newTaskList;\n        }\n    }\n    enqueueTask(task, prioritize = false) {\n        if (prioritize) {\n            this._priorityTasks.push(task);\n        }\n        else {\n            this._tasksWaiting.push(task);\n        }\n        this.runTasks();\n    }\n    runTasks() {\n        if (this._tasksWaiting.length + this._priorityTasks.length === 0 || this._currentConnectionCount >= this._maxConcurrentConnections) {\n            return;\n        }\n        while (this._tasksWaiting.length + this._priorityTasks.length !== 0 && this._currentConnectionCount < this._maxConcurrentConnections) {\n            this._currentConnectionCount++;\n            const task = this._priorityTasks.length > 0 ? this._priorityTasks.shift() : this._tasksWaiting.shift();\n            Craft.postActionRequest(task.action, task.params, this.processResponse.bind(this));\n        }\n    }\n    _updateCurrentIndexingSession() {\n        for (const session of Object.values(this.indexingSessions)) {\n            if (session.getSessionStatus() !== SessionStatus.QUEUE\n                && session.getSessionStatus() !== SessionStatus.CLI\n                && session.getSessionStatus() !== SessionStatus.ACTIONREQUIRED) {\n                this._currentIndexingSession = session.getSessionId();\n                return;\n            }\n        }\n    }\n    /**\n     * Create a session from the data model.\n     *\n     * @param sessionData\n     * @private\n     */\n    createSessionFromModel(sessionData) {\n        return new AssetIndexingSession(sessionData, this);\n    }\n}\nclass AssetIndexingSession {\n    constructor(model, indexer) {\n        this.indexingSessionData = model;\n        this.indexer = indexer;\n    }\n    /**\n     * Get the session id\n     */\n    getSessionId() {\n        return this.indexingSessionData.id;\n    }\n    /**\n     * Get the remaining entry count for this sessions.\n     */\n    getEntriesRemaining() {\n        return this.indexingSessionData.totalEntries - this.indexingSessionData.processedEntries;\n    }\n    /**\n     * Get the session status.\n     */\n    getSessionStatus() {\n        if (this.indexingSessionData.isCli) {\n            return SessionStatus.CLI;\n        }\n        if (this.indexingSessionData.queueId) {\n            return SessionStatus.QUEUE;\n        }\n        if (this.indexingSessionData.actionRequired) {\n            return SessionStatus.ACTIONREQUIRED;\n        }\n        if (this.indexer.currentIndexingSession === this.indexingSessionData.id) {\n            return SessionStatus.ACTIVE;\n        }\n        return SessionStatus.WAITING;\n    }\n    /**\n     * Create row html as a JQuery object based on an indexing sessions\n     * @param session\n     * @private\n     */\n    getIndexingSessionRowHtml() {\n        const $tr = $('<tr class=\"indexingSession\" data-session-id=\"' + this.getSessionId() + '\">');\n        $tr.append('<td>' + Object.values(this.indexingSessionData.indexedVolumes).join(', ') + '</td>');\n        $tr.append('<td>' + this.indexingSessionData.dateCreated + '</td>');\n        $tr.append('<td>' + this.indexingSessionData.dateUpdated + '</td>');\n        const $progressCell = $('<td class=\"progress\"></td>').css('position', 'relative');\n        const progressBar = new Craft.ProgressBar($progressCell, false);\n        progressBar.setItemCount(this.indexingSessionData.totalEntries);\n        progressBar.setProcessedItemCount(this.indexingSessionData.processedEntries);\n        progressBar.updateProgressBar();\n        progressBar.showProgressBar();\n        $tr.append($progressCell.data('progressBar', progressBar));\n        $tr.append('<td>' + this.getSessionStatusMessage() + '</td>');\n        const $actions = this.getActionButtons();\n        $('<td></td>').append($actions).appendTo($tr);\n        return $tr;\n    }\n    /**\n     * Get action buttons for an indexing session\n     * @param session\n     * @private\n     */\n    getActionButtons() {\n        if (this.getSessionStatus() === SessionStatus.QUEUE || this.getSessionStatus() === SessionStatus.CLI) {\n            return $();\n        }\n        const $buttons = $('<div class=\"buttons\"></div>');\n        if (this.getSessionStatus() == SessionStatus.ACTIONREQUIRED) {\n            const reviewMessage = Craft.t('app', 'Review');\n            $buttons.append($('<button />', {\n                type: 'button',\n                'class': 'btn submit',\n                title: reviewMessage,\n                \"aria-label\": reviewMessage,\n            }).text(reviewMessage).on('click', ev => {\n                const $container = $(ev.target).parent();\n                if ($container.hasClass('disabled')) {\n                    return;\n                }\n                $container.addClass('disabled');\n                this.indexer.getReviewData(this);\n            }));\n        }\n        const discardMessage = Craft.t('app', 'Discard');\n        $buttons.append($('<button />', {\n            type: 'button',\n            'class': 'btn submit',\n            title: discardMessage,\n            \"aria-label\": discardMessage,\n        }).text(discardMessage).on('click', ev => {\n            if ($buttons.hasClass('disabled')) {\n                return;\n            }\n            $buttons.addClass('disabled');\n            this.indexer.stopIndexingSession(this);\n        }));\n        return $buttons;\n    }\n    /**\n     * Get the session status verbose message\n     *\n     * @param status\n     */\n    getSessionStatusMessage() {\n        switch (this.getSessionStatus()) {\n            case SessionStatus.ACTIONREQUIRED:\n                return Craft.t('app', 'Waiting for review');\n                break;\n            case SessionStatus.ACTIVE:\n                return Craft.t('app', 'Active');\n                break;\n            case SessionStatus.WAITING:\n                return Craft.t('app', 'Waiting');\n                break;\n            case SessionStatus.QUEUE:\n                return Craft.t('app', 'Running in background');\n                break;\n            case SessionStatus.CLI:\n                return Craft.t('app', 'Running via CLI');\n                break;\n        }\n    }\n    /**\n     * Return a list of missing entries for this session\n     */\n    getMissingEntries() {\n        return this.indexingSessionData.missingEntries;\n    }\n    /**\n     * Return a list of skipped entries for this session\n     */\n    getSkippedEntries() {\n        return this.indexingSessionData.skippedEntries;\n    }\n}\n"]}
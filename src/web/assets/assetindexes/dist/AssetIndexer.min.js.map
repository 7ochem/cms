{"version":3,"sources":["assetindexes/src/AssetIndexer.js"],"names":["SessionStatus","IndexingActions","AssetIndexer","constructor","$indexingSessionTable","sessions","maxConcurrentConnections","this","_currentConnectionCount","_tasksWaiting","_priorityTasks","_prunedSessionIds","_currentlyReviewing","_currentIndexingSession","indexingSessions","createSessionFromModel","sessionModel","_maxConcurrentConnections","ACTIONREQUIRED","reviewSessionId","getSessionStatus","session","updateIndexingSessionData","performIndexingStep","currentIndexingSession","indexingSession","getSessionId","renderIndexingSessionRow","$row","undefined","includes","remove","find","length","addClass","getIndexingSessionRowHtml","$existing","replaceWith","append","removeClass","discardIndexingSession","sessionId","processResponse","response","textStatus","error","alert","stop","runTasks","skipDialog","reviewSession","_updateCurrentIndexingSession","getReviewData","action","OVERVIEW","params","enqueueTask","task","pruneWaitingTasks","$confirmBody","$","missingEntries","files","Object","entries","missingFolders","folders","getSkippedEntries","skippedFiles","skippedFilesList","skippedFile","Craft","t","haveMissingItems","missingFiles","itemText","items","id","uri","translationParams","appendTo","Garnish","$bod","$body","$modal","html","$footer","modal","Modal","hideOnEsc","hideOnShadeClick","onHide","type","on","ev","stopIndexingSession","hide","$buttons","class","text","initUiElements","preventDefault","getPostData","postParams","expandPostArray","postData","FINISH","startIndexing","cb","$cancelBtn","concurrentSlots","i","Math","min","getEntriesRemaining","PROCESS","STOP","newTaskList","push","modified","prioritize","shift","postActionRequest","callback","values","sessionData","AssetIndexingSession","model","indexer","indexingSessionData","totalEntries","processedEntries","ACTIVE","$tr","indexedVolumes","dateCreated","$progressCell","css","progressBar","ProgressBar","updateProgressBar","getSessionStatusMessage","$actions","getActionButtons","reviewMessage","title","aria-label","$container","target","parent","hasClass","discardMessage","getMissingEntries","skippedEntries"],"mappings":"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","file":"AssetIndexer.min.js","sourcesContent":["\"use strict\";\nvar SessionStatus;\n(function (SessionStatus) {\n    SessionStatus[SessionStatus[\"ACTIONREQUIRED\"] = 0] = \"ACTIONREQUIRED\";\n    SessionStatus[SessionStatus[\"ACTIVE\"] = 1] = \"ACTIVE\";\n    SessionStatus[SessionStatus[\"WAITING\"] = 2] = \"WAITING\";\n})(SessionStatus || (SessionStatus = {}));\nvar IndexingActions;\n(function (IndexingActions) {\n    IndexingActions[\"START\"] = \"asset-indexes/start-indexing\";\n    IndexingActions[\"STOP\"] = \"asset-indexes/stop-indexing-session\";\n    IndexingActions[\"PROCESS\"] = \"asset-indexes/process-indexing-session\";\n    IndexingActions[\"OVERVIEW\"] = \"asset-indexes/indexing-session-overview\";\n    IndexingActions[\"FINISH\"] = \"asset-indexes/finish-indexing-session\";\n})(IndexingActions || (IndexingActions = {}));\n;\n/**\n * Actual classes start here\n */\n// Asset Indexer\n// =====================================================================================\nclass AssetIndexer {\n    /**\n     * @param $element The indexing session table\n     * @param sessions Existing indexing sessions\n     */\n    constructor($indexingSessionTable, sessions, maxConcurrentConnections = 3) {\n        this._currentIndexingSession = null;\n        this._currentConnectionCount = 0;\n        this._tasksWaiting = [];\n        this._priorityTasks = [];\n        this._prunedSessionIds = [];\n        this._currentlyReviewing = false;\n        this.indexingSessions = {};\n        this._maxConcurrentConnections = maxConcurrentConnections;\n        this.$indexingSessionTable = $indexingSessionTable;\n        this.indexingSessions = {};\n        let reviewSessionId = 0;\n        for (const sessionModel of sessions) {\n            let session = this.createSessionFromModel(sessionModel);\n            if (session.getSessionStatus() === SessionStatus.ACTIONREQUIRED && !reviewSessionId) {\n                reviewSessionId = session.getSessionId();\n            }\n            if (!reviewSessionId\n                && this._currentIndexingSession == null\n                && session.getSessionStatus() !== SessionStatus.ACTIONREQUIRED) {\n                this._currentIndexingSession = session.getSessionId();\n            }\n            this.updateIndexingSessionData(session);\n        }\n        if (this._currentIndexingSession) {\n            this.performIndexingStep();\n        }\n    }\n    get currentIndexingSession() {\n        return this._currentIndexingSession;\n    }\n    /**\n     * Update indexing session store\n     * @param session\n     */\n    updateIndexingSessionData(indexingSession) {\n        this.indexingSessions[indexingSession.getSessionId()] = indexingSession;\n        this.renderIndexingSessionRow(indexingSession);\n    }\n    /**\n     * Return a rendered indexing session row based on its id\n     * @param sessionId\n     */\n    renderIndexingSessionRow(session) {\n        let $row;\n        if (session === undefined) {\n            return;\n        }\n        if (!this.indexingSessions[session.getSessionId()] || this._prunedSessionIds.includes(session.getSessionId())) {\n            this.$indexingSessionTable.find('tr[data-session-id=\"' + session.getSessionId() + '\"]').remove();\n            if (this.$indexingSessionTable.find('tbody tr').length == 0) {\n                this.$indexingSessionTable.addClass('hidden');\n            }\n            return;\n        }\n        $row = session.getIndexingSessionRowHtml();\n        const $existing = this.$indexingSessionTable.find('tr[data-session-id=\"' + session.getSessionId() + '\"]');\n        if ($existing.length > 0) {\n            $existing.replaceWith($row);\n        }\n        else {\n            this.$indexingSessionTable.find('tbody').append($row);\n        }\n        this.$indexingSessionTable.removeClass('hidden');\n    }\n    /**\n     * Remove an indexing session\n     * @param sessionId\n     * @protected\n     */\n    discardIndexingSession(sessionId) {\n        const session = this.indexingSessions[sessionId];\n        delete this.indexingSessions[sessionId];\n        if (this._currentIndexingSession === sessionId) {\n            this._currentIndexingSession = null;\n        }\n        this.renderIndexingSessionRow(session);\n        this.runTasks();\n    }\n    /**\n     * Process an indexing response.\n     *\n     * @param response\n     * @param textStatus\n     */\n    processResponse(response, textStatus) {\n        this._currentConnectionCount--;\n        if (textStatus === 'success' && response.error) {\n            alert(response.error);\n            if (response.stop) {\n                this.discardIndexingSession(response.stop);\n            }\n            // A mere error shall not stop the party.\n            this.runTasks();\n            return;\n        }\n        if (textStatus === 'success' && response.session) {\n            const session = this.createSessionFromModel(response.session);\n            this.indexingSessions[session.getSessionId()] = session;\n            this.renderIndexingSessionRow(session);\n            this._updateCurrentIndexingSession();\n            if (session.getSessionStatus() === SessionStatus.ACTIONREQUIRED && !response.skipDialog) {\n                if (!this._prunedSessionIds.includes(this._currentIndexingSession)) {\n                    this.reviewSession(session);\n                }\n                else {\n                    this.runTasks();\n                }\n            }\n            else if (!this._prunedSessionIds.includes(this._currentIndexingSession)) {\n                this.performIndexingStep();\n            }\n            else {\n                this.runTasks();\n            }\n        }\n        this._updateCurrentIndexingSession();\n        if (textStatus === 'success' && response.stop) {\n            this.discardIndexingSession(response.stop);\n        }\n    }\n    getReviewData(session) {\n        const task = {\n            sessionId: session.getSessionId(),\n            action: IndexingActions.OVERVIEW,\n            params: { sessionId: session.getSessionId() },\n            callback: () => {\n                this.renderIndexingSessionRow(session);\n            }\n        };\n        this.enqueueTask(task);\n    }\n    reviewSession(session) {\n        if (this._currentlyReviewing) {\n            return;\n        }\n        this._currentlyReviewing = true;\n        this.pruneWaitingTasks(session.getSessionId());\n        let $confirmBody = $('<div></div>');\n        const missingEntries = session.getMissingEntries();\n        const missingFiles = missingEntries.files ? Object.entries(missingEntries.files) : [];\n        const missingFolders = missingEntries.folders ? Object.entries(missingEntries.folders) : [];\n        const skippedFiles = session.getSkippedEntries();\n        if (skippedFiles.length) {\n            let skippedFilesList = '';\n            for (const skippedFile of skippedFiles) {\n                skippedFilesList += `<li>${skippedFile}</li>`;\n            }\n            $confirmBody.append(`\n                <h2>${Craft.t('app', 'Skipped files')}</h2>\n                <p>${Craft.t('app', 'The following items were not indexed.')}</p>\n                <ul>\n                    ${skippedFilesList}\n                </ul>\n            `);\n        }\n        const haveMissingItems = missingFiles.length || missingFolders.length;\n        if (haveMissingItems) {\n            let itemText = '';\n            if (missingFiles.length) {\n                itemText += 'files';\n            }\n            if (missingFiles.length && missingFolders.length) {\n                itemText += ' and ';\n            }\n            if (missingFolders.length) {\n                itemText += 'folders';\n            }\n            const translationParams = { items: itemText };\n            let missingEntries = '';\n            for (const [id, uri] of missingFolders) {\n                missingEntries += `<li><label><input type=\"checkbox\" checked=\"checked\" name=\"deleteFolder[]\" value=\"${id}\"> ${uri}</label></li>`;\n            }\n            for (const [id, uri] of missingFiles) {\n                missingEntries += `<li><label><input type=\"checkbox\" checked=\"checked\" name=\"deleteAsset[]\" value=\"${id}\"> ${uri}</label></li>`;\n            }\n            $confirmBody.append($(`\n                <h2>${Craft.t('app', 'Missing {items}', translationParams)}</h2>\n                <p>${Craft.t('app', 'The following {items} could not be found. Should they be deleted from the index?', translationParams)}</p>\n                <ul>\n                    ${missingEntries}\n                </ul>\n            `));\n        }\n        const $modal = $('<form class=\"modal fitted confirmmodal\"/>').appendTo(Garnish.$bod);\n        const $body = $('<div class=\"body\"/>').appendTo($modal).html($confirmBody.html());\n        const $footer = $('<footer class=\"footer\"/>').appendTo($modal);\n        const $buttons = $('<div class=\"buttons right\"/>').appendTo($footer);\n        const modal = new Garnish.Modal($modal, {\n            hideOnEsc: false,\n            hideOnShadeClick: false,\n            onHide: () => {\n                this._currentlyReviewing = false;\n            }\n        });\n        if (haveMissingItems) {\n            let $cancelBtn = $('<button/>', {\n                type: 'button',\n                class: 'btn',\n                text: Craft.t('app', 'Keep them'),\n            }).on('click', ev => {\n                ev.preventDefault();\n                this.stopIndexingSession(session);\n                modal.hide();\n            }).appendTo($buttons);\n            $('<button/>', {\n                type: 'submit',\n                class: 'btn submit',\n                text: Craft.t('app', 'Delete them'),\n            }).appendTo($buttons);\n        }\n        else {\n            $('<button/>', {\n                type: 'submit',\n                class: 'btn submit',\n                text: Craft.t('app', 'OK'),\n            }).appendTo($buttons);\n        }\n        Craft.initUiElements($body);\n        modal.updateSizeAndPosition();\n        $modal.on('submit', (ev) => {\n            ev.preventDefault();\n            modal.hide();\n            const postData = Garnish.getPostData($body);\n            const postParams = Craft.expandPostArray(postData);\n            postParams.sessionId = session.getSessionId();\n            // Make this the next task for sure?\n            const task = {\n                sessionId: session.getSessionId(),\n                action: IndexingActions.FINISH,\n                params: postParams\n            };\n            this.enqueueTask(task, true);\n        });\n    }\n    startIndexing(params, cb) {\n        Craft.postActionRequest(IndexingActions.START, params, (response, textStatus) => {\n            this.processResponse(response, textStatus);\n            cb();\n        });\n    }\n    performIndexingStep() {\n        if (!this._currentIndexingSession) {\n            this._updateCurrentIndexingSession();\n        }\n        if (!this._currentIndexingSession) {\n            return;\n        }\n        const session = this.indexingSessions[this._currentIndexingSession];\n        const concurrentSlots = this._maxConcurrentConnections - this._currentConnectionCount;\n        // Queue up at least enough tasks to use up all the free connections of finish the session.\n        for (let i = 0; i < Math.min(concurrentSlots, session.getEntriesRemaining()); i++) {\n            const task = {\n                sessionId: session.getSessionId(),\n                action: IndexingActions.PROCESS,\n                params: { sessionId: this._currentIndexingSession }\n            };\n            this.enqueueTask(task);\n        }\n    }\n    /**\n     * Stop and discard an indexing session.\n     *\n     * @param session\n     */\n    stopIndexingSession(session) {\n        this.pruneWaitingTasks(session.getSessionId());\n        const task = {\n            sessionId: session.getSessionId(),\n            action: IndexingActions.STOP,\n            params: { sessionId: session.getSessionId() }\n        };\n        this.enqueueTask(task, true);\n    }\n    /**\n     * Pune the waiting task list by removing all tasks for a session id.\n     *\n     * @param sessionId\n     */\n    pruneWaitingTasks(sessionId) {\n        const newTaskList = [];\n        let modified = false;\n        this._prunedSessionIds.push(sessionId);\n        for (const task of this._tasksWaiting) {\n            if (task.sessionId !== sessionId) {\n                newTaskList.push(task);\n            }\n            else {\n                modified = true;\n            }\n        }\n        if (modified) {\n            this._tasksWaiting = newTaskList;\n        }\n    }\n    enqueueTask(task, prioritize = false) {\n        if (prioritize) {\n            this._priorityTasks.push(task);\n        }\n        else {\n            this._tasksWaiting.push(task);\n        }\n        this.runTasks();\n    }\n    runTasks() {\n        if (this._tasksWaiting.length + this._priorityTasks.length === 0 || this._currentConnectionCount >= this._maxConcurrentConnections) {\n            return;\n        }\n        while (this._tasksWaiting.length + this._priorityTasks.length !== 0 && this._currentConnectionCount < this._maxConcurrentConnections) {\n            this._currentConnectionCount++;\n            const task = this._priorityTasks.length > 0 ? this._priorityTasks.shift() : this._tasksWaiting.shift();\n            Craft.postActionRequest(task.action, task.params, (response, textStatus) => {\n                this.processResponse(response, textStatus);\n                if (task.callback) {\n                    task.callback();\n                }\n            });\n        }\n    }\n    _updateCurrentIndexingSession() {\n        for (const session of Object.values(this.indexingSessions)) {\n            if (session.getSessionStatus() !== SessionStatus.ACTIONREQUIRED) {\n                this._currentIndexingSession = session.getSessionId();\n                return;\n            }\n        }\n    }\n    /**\n     * Create a session from the data model.\n     *\n     * @param sessionData\n     * @private\n     */\n    createSessionFromModel(sessionData) {\n        return new AssetIndexingSession(sessionData, this);\n    }\n}\nclass AssetIndexingSession {\n    constructor(model, indexer) {\n        this.indexingSessionData = model;\n        this.indexer = indexer;\n    }\n    /**\n     * Get the session id\n     */\n    getSessionId() {\n        return this.indexingSessionData.id;\n    }\n    /**\n     * Get the remaining entry count for this sessions.\n     */\n    getEntriesRemaining() {\n        return this.indexingSessionData.totalEntries - this.indexingSessionData.processedEntries;\n    }\n    /**\n     * Get the session status.\n     */\n    getSessionStatus() {\n        if (this.indexingSessionData.actionRequired) {\n            return SessionStatus.ACTIONREQUIRED;\n        }\n        if (this.indexer.currentIndexingSession === this.indexingSessionData.id) {\n            return SessionStatus.ACTIVE;\n        }\n        return SessionStatus.WAITING;\n    }\n    /**\n     * Create row html as a JQuery object based on an indexing sessions\n     * @param session\n     * @private\n     */\n    getIndexingSessionRowHtml() {\n        const $tr = $('<tr class=\"indexingSession\" data-session-id=\"' + this.getSessionId() + '\">');\n        $tr.append('<td><ul><li>' + Object.values(this.indexingSessionData.indexedVolumes).join('</li><li>') + '</li></ul></td>');\n        $tr.append('<td>' + this.indexingSessionData.dateCreated + '</td>');\n        const $progressCell = $('<td class=\"progress\"><div class=\"progressContainer\"></div></td>').css('position', 'relative');\n        const progressBar = new Craft.ProgressBar($progressCell.find('.progressContainer'), false);\n        progressBar.setItemCount(this.indexingSessionData.totalEntries);\n        progressBar.setProcessedItemCount(this.indexingSessionData.processedEntries);\n        progressBar.updateProgressBar();\n        progressBar.showProgressBar();\n        $progressCell.data('progressBar', progressBar);\n        $progressCell.find('.progressContainer').append(`<div class=\"progressInfo\">${this.indexingSessionData.processedEntries} / ${this.indexingSessionData.totalEntries}</div>`);\n        $tr.append($progressCell);\n        $tr.append('<td>' + this.getSessionStatusMessage() + '</td>');\n        const $actions = this.getActionButtons();\n        $('<td></td>').append($actions).appendTo($tr);\n        return $tr;\n    }\n    /**\n     * Get action buttons for an indexing session\n     * @param session\n     * @private\n     */\n    getActionButtons() {\n        const $buttons = $('<div class=\"buttons\"></div>');\n        if (this.getSessionStatus() == SessionStatus.ACTIONREQUIRED) {\n            const reviewMessage = Craft.t('app', 'Review');\n            $buttons.append($('<button />', {\n                type: 'button',\n                'class': 'btn submit',\n                title: reviewMessage,\n                \"aria-label\": reviewMessage,\n            }).text(reviewMessage).on('click', ev => {\n                const $container = $(ev.target).parent();\n                if ($container.hasClass('disabled')) {\n                    return;\n                }\n                $container.addClass('disabled');\n                this.indexer.getReviewData(this);\n            }));\n        }\n        const discardMessage = Craft.t('app', 'Discard');\n        $buttons.append($('<button />', {\n            type: 'button',\n            'class': 'btn submit',\n            title: discardMessage,\n            \"aria-label\": discardMessage,\n        }).text(discardMessage).on('click', ev => {\n            if ($buttons.hasClass('disabled')) {\n                return;\n            }\n            $buttons.addClass('disabled');\n            this.indexer.stopIndexingSession(this);\n        }));\n        return $buttons;\n    }\n    /**\n     * Get the session status verbose message\n     *\n     * @param status\n     */\n    getSessionStatusMessage() {\n        switch (this.getSessionStatus()) {\n            case SessionStatus.ACTIONREQUIRED:\n                return Craft.t('app', 'Waiting for review');\n                break;\n            case SessionStatus.ACTIVE:\n                return Craft.t('app', 'Active');\n                break;\n            case SessionStatus.WAITING:\n                return Craft.t('app', 'Waiting');\n                break;\n        }\n    }\n    /**\n     * Return a list of missing entries for this session\n     */\n    getMissingEntries() {\n        return this.indexingSessionData.missingEntries;\n    }\n    /**\n     * Return a list of skipped entries for this session\n     */\n    getSkippedEntries() {\n        return this.indexingSessionData.skippedEntries;\n    }\n}\n"]}